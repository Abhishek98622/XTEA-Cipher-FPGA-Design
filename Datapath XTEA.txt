library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;

entity Datapath is
    Generic(
        W:integer := 16;
        r:integer := 8
    );
    Port (
        Clk: in STD_LOGIC; 
        Rst: in STD_LOGIC; 
        M: in STD_LOGIC_VECTOR(2*W-1 downto 0); 
        Ki: in STD_LOGIC_VECTOR(W-1 downto 0);
        i: in STD_LOGIC_VECTOR(1 downto 0);
        Write_ki: in STD_LOGIC;
        Write_M: in STD_LOGIC;
        env0: in STD_LOGIC;
        env1: in STD_LOGIC;
        enSUM: in std_LOGIC;
        enj: in STD_LOGIC;
        enc: in STD_LOGIC;
        ldj: in STD_LOGIC;
        cyclenum: in STD_LOGIC;
        zj: out STD_LOGIC;
        C: out STD_LOGIC_VECTOR(2*W-1 downto 0)
     );
end Datapath;

architecture Mixed of Datapath is

    constant DELTA : STD_LOGIC_VECTOR(w-1 downto 0) := (others => '0');

    Signal V0: STD_LOGIC_VECTOR(w-1 downto 0);
    Signal V1: STD_LOGIC_VECTOR(w-1 downto 0);
    Signal V0_V1: STD_LOGIC_VECTOR(w-1 downto 0);
--    Signal V1_1: STD_LOGIC_VECTOR(w-1 downto 0);
    Signal W00_W10: STD_LOGIC_VECTOR(w-1 downto 0);
    Signal W01_W11: STD_LOGIC_VECTOR(w-1 downto 0);
--    Signal W10: STD_LOGIC_VECTOR(w-1 downto 0);
--    Signal W11: STD_LOGIC_VECTOR(w-1 downto 0);
    Signal T0_T1: STD_LOGIC_VECTOR(w-1 downto 0);
--    Signal T1: STD_LOGIC_VECTOR(w-1 downto 0);
    Signal SUM: STD_LOGIC_VECTOR(w-1 downto 0);
    Signal SUM_1: STD_LOGIC_VECTOR(w-1 downto 0);
    Signal KEYout: STD_LOGIC_VECTOR(w-1 downto 0);
    Signal Addr: STD_LOGIC_VECTOR(1 downto 0);
    Signal SUM1: STD_LOGIC_VECTOR(1 downto 0);
    Signal SUM2: STD_LOGIC_VECTOR(1 downto 0);
    Signal inputs: STD_LOGIC_VECTOR(1 downto 0);
    Signal jm1: integer;
    
    Signal Output: STD_LOGIC_VECTOR(2*w-1 downto 0):= (OTHERS => '0');

begin

        SUM1 <= SUM(12 downto 11);
        SUM2 <= SUM(1 downto 0);

        RAM: Entity work.RAM
        Generic Map(w => w)
        port map(
        ADDR => Addr,
        DIN => Ki,
        DOUT => KEYout,
        WE => Write_ki,
        CLK => Clk
        );

        REG1: PROCESS(Clk)
        --Instantiating MUX 1 in the Register
        BEGIN
            IF rising_edge(Clk) THEN
                IF env0 = '1' THEN
                    IF Write_M = '1' THEN
                        V0 <= M(2*w-1 downto w);
                    else
                    -- Assigning V0 in the first clock cycle of the loop 
                        IF Cyclenum = '1' THEN
                            V0 <= V0_V1;
                        END IF;
                    END IF;
                END IF;
            END IF;
        END PROCESS;
                
        REG2: PROCESS(Clk)
        --Instantiating MUX 2 in the Register
        BEGIN
            IF rising_edge(Clk) THEN
                IF env1 = '1' THEN
                    IF Write_M = '1' THEN
                        V1 <= M(w-1 downto 0);
                    else
                        -- Assigning V0 in the Second clock cycle of the loop 
                        IF Cyclenum = '0' THEN
                            V1 <= V0_V1;
                        END IF;
                    END IF;
                END IF;
            END IF;
        END PROCESS;
        
        REG3: PROCESS(Clk)
        --Instantiating SUM Register
        BEGIN
            IF rising_edge(Clk) THEN
                IF Write_M = '0' THEN
                    IF ensum = '1' THEN
                        SUM_1 <= STD_LOGIC_VECTOR(unsigned(SUM) + unsigned(DELTA));                         
                    END IF;
                ELSE
                    SUM_1 <= (OTHERS=>'0');
                END IF;
            END IF;
            SUM <= SUM_1;
        END PROCESS;
    
 -- Select signal for the Adrress of the RAM
        inputs <= cyclenum & Write_Ki;
    
        with inputs select
        Addr <= SUM1 when "10",
                SUM2 when "11",
                i when others;         

--        PROCESS(cyclenum)
        
--        BEGIN
--            IF Cyclenum = '1' THEN
--                W00 <= STD_LOGIC_VECTOR(unsigned((V0(w-5 downto 0) & "0000") XOR ("00000" & V0(w-1 downto 5))) + unsigned(V0));
--                W01 <= STD_LOGIC_VECTOR(unsigned(KEYout) + unsigned(SUM_1));
--            ELSE
--                W10 <= STD_LOGIC_VECTOR(unsigned((V1(w-5 downto 0) & "0000") XOR ("00000" & V1(w-1 downto 5))) + unsigned(V1));
--                W11 <= STD_LOGIC_VECTOR(unsigned(KEYout) + unsigned(SUM_1));
--            END IF;
--        END PROCESS;
            
        W00_W10 <= STD_LOGIC_VECTOR(unsigned((V0(w-5 downto 0) & "0000") XOR ("00000" & V0(w-1 downto 5))) + unsigned(V0))
         WHEN Cyclenum = '1' ELSE
        STD_LOGIC_VECTOR(unsigned((V1(w-5 downto 0) & "0000") XOR ("00000" & V1(w-1 downto 5))) + unsigned(V1));
            
        W01_W11 <= STD_LOGIC_VECTOR(unsigned(KEYout) + unsigned(SUM_1));
        
        T0_T1 <= W00_W10 XOR W01_W11;
        
        V0_V1 <= STD_LOGIC_VECTOR(unsigned(T0_T1) + unsigned(V1))
            WHEN cyclenum = '1' ELSE
        STD_LOGIC_VECTOR(unsigned(T0_T1) + unsigned(V0));
        
        --Output Logic
        OPREG: PROCESS(enc)
        BEGIN
            IF enc = '1' THEN
                Output <= V0 & V0_V1;
            END IF;
        END PROCESS;

        C <= Output;                         
                        
        -- Counter J 
        counterJ: process(clk)
            begin
            if rising_edge(clk) then
                if ldj = '1' then
                    jm1 <= 0;
                elsif Enj = '1' then
                    jm1 <= jm1 + 1;
                end if;          
            end if;
        end process;
        
        zj <= '1' WHEN (jm1 = r-1) ELSE '0';
        
end Mixed;
